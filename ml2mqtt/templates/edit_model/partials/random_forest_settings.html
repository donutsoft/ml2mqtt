<div class="settingsGroup">
  <h3>Classifier Settings</h3>

  <div class="formField">
    <label for="classifier">Classifier</label>
    <select id="classifier" name="classifier" class="styledSelect" onchange="onClassifierChange()">
      <option value="RandomForest" {% if model.params.modelParameters.model_type == 'RandomForest' %}selected{% endif %}>Random Forest</option>
      <option value="KNN" {% if model.params.modelParameters.model_type == 'KNN' %}selected{% endif %}>K-Nearest Neighbors</option>
    </select>
  </div>

  <div class="formField buttonRow">
    <button type="submit" name="action" value="tune" class="btn small">Automatically Tune Model</button>
    <button type="button" onclick="toggleManualParams()" id="showAdvancedBtn" class="btn small">Manual Settings</button>
  </div>

  <div id="advancedParams" class="manualSettings" style="display: none;">
    {% if model.params.modelParameters.model_type == 'RandomForest' %}
    <div class="formField">
      <label>Number of Trees</label>
      <input type="number" name="nEstimators" value="{{ model.params.modelParameters.model_parameters.RandomForest.n_estimators }}">
    </div>
    <div class="formField">
      <label>Maximum Tree Depth</label>
      <input type="number" name="maxDepth" value="{{ model.params.modelParameters.model_parameters.RandomForest.max_depth }}">
    </div>
    <div class="formField">
      <label>Minimum Samples to Split</label>
      <input type="number" name="minSamplesSplit" value="{{ model.params.modelParameters.model_parameters.RandomForest.min_samples_split }}">
    </div>
    <div class="formField">
      <label>Minimum Samples per Leaf</label>
      <input type="number" name="minSamplesLeaf" value="{{ model.params.modelParameters.model_parameters.RandomForest.min_samples_leaf }}">
    </div>
    <div class="formField">
      <label>Max Features Per Split</label>
      <select name="maxFeatures" class="styledSelect">
        {% set selected = model.params.modelParameters.model_parameters.RandomForest.max_features or 'sqrt' %}
        <option value="sqrt" {% if selected == 'sqrt' %}selected{% endif %}>Square Root (sqrt)</option>
        <option value="log2" {% if selected == 'log2' %}selected{% endif %}>Log Base 2 (log2)</option>
        <option value="None" {% if selected == 'None' %}selected{% endif %}>All Features</option>
      </select>
    </div>
    <div class="formField">
      <label>Class Weight</label>
      <select name="classWeight" class="styledSelect">
        {% set selected = model.params.modelParameters.model_parameters.RandomForest.class_weight or 'None' %}
        <option value="None" {% if selected == 'None' %}selected{% endif %}>None</option>
        <option value="balanced" {% if selected == 'balanced' %}selected{% endif %}>Balanced</option>
        <option value="balanced_subsample" {% if selected == 'balanced_subsample' %}selected{% endif %}>Balanced Subsample</option>
      </select>
    </div>
    <div class="formField formFieldRow">
      <div class="labelColumn">
        <label for="bootstrap">Use Bootstrap Samples</label>
      </div>
      <div class="toggleColumn">
        <label class="switch">
          <input type="checkbox" id="bootstrap" name="bootstrap" {% if model.params.modelParameters.model_parameters.RandomForest.bootstrap != False %}checked{% endif %} onchange="toggleOobField()">
          <span class="slider"></span>
        </label>
      </div>
    </div>
    <div class="formField formFieldRow" id="oobRow" style="{% if not model.params.modelParameters.model_parameters.RandomForest.bootstrap %}display: none;{% endif %}">
      <div class="labelColumn">
        <label for="oobScore">Use Out-of-Bag Scoring</label>
      </div>
      <div class="toggleColumn">
        <label class="switch">
          <input type="checkbox" id="oobScore" name="oobScore" {% if model.params.modelParameters.model_parameters.RandomForest.oob_score %}checked{% endif %}>
          <span class="slider"></span>
        </label>
      </div>
    </div>
    {% elif model.params.modelParameters.model_type == 'KNN' %}
    <div class="formField">
      <label>Number of Neighbors</label>
      <input type="number" name="nNeighbors" value="{{ model.params.modelParameters.model_parameters.KNN.n_neighbors }}">
    </div>
    <div class="formField">
      <label>Weight Function</label>
      <select name="weights" class="styledSelect">
        {% set selected = model.params.modelParameters.model_parameters.KNN.weights or 'uniform' %}
        <option value="uniform" {% if selected == 'uniform' %}selected{% endif %}>Uniform</option>
        <option value="distance" {% if selected == 'distance' %}selected{% endif %}>Distance</option>
      </select>
    </div>
    <div class="formField">
      <label>Distance Metric</label>
      <select name="metric" class="styledSelect">
        {% set selected = model.params.modelParameters.model_parameters.KNN.metric or 'minkowski' %}
        <option value="minkowski" {% if selected == 'minkowski' %}selected{% endif %}>Minkowski</option>
        <option value="euclidean" {% if selected == 'euclidean' %}selected{% endif %}>Euclidean</option>
        <option value="manhattan" {% if selected == 'manhattan' %}selected{% endif %}>Manhattan</option>
      </select>
    </div>
    {% endif %}

    <div style="text-align: right; margin-top: 2rem;">
      <button id="saveBtn" onclick="saveClassifierSettings()" class="btn primary">Save Settings</button>
    </div>
  </div>
</div>


<div id="tuneToast" class="toast">
  <span id="toastMessage"></span><span id="toastDots"></span>
</div>

<script>
const modelName = "{{ model.name }}";

document.querySelector('button[name="action"][value="tune"]').addEventListener("click", function (e) {
  e.preventDefault();
  showToast("Working", false, true);
  runTuningRequest();
});

window.addEventListener("DOMContentLoaded", () => {
  showManualParams(localStorage.getItem("showManualParams") == "true");
  if (localStorage.getItem("tuningComplete") === "true") {
    localStorage.removeItem("tuningComplete");
    window.scrollTo({ top: 0, behavior: "smooth" });
    showToast("Finished!");
  }
});

async function runTuningRequest() {
  try {
    const response = await fetch("{{ url_for('autoTuneModel', modelName=model.name) }}", {
      method: "POST",
      headers: { "Content-Type": "application/json" }
    });

    if (response.ok) {
      const result = await response.json();
      localStorage.setItem("tuningComplete", "true");
      window.location.reload();
    } else {
      showToast("Error occurred.", true);
    }
  } catch (err) {
    showToast("Server error.", true);
  }
}

async function saveClassifierSettings() {
  const saveBtn = document.getElementById("saveBtn");
  saveBtn.disabled = true;

  const classifier = document.getElementById("classifier").value;
  const formData = new FormData();
  formData.append("modelType", classifier);

  if (classifier === "RandomForest") {
    const fields = {
      nEstimators: document.querySelector('[name="nEstimators"]'),
      maxDepth: document.querySelector('[name="maxDepth"]'),
      minSamplesSplit: document.querySelector('[name="minSamplesSplit"]'),
      minSamplesLeaf: document.querySelector('[name="minSamplesLeaf"]'),
      maxFeatures: document.querySelector('[name="maxFeatures"]'),
      classWeight: document.querySelector('[name="classWeight"]'),
      bootstrap: document.getElementById("bootstrap"),
      oobScore: document.getElementById("oobScore")
    };

    const requiredNumericFields = ['nEstimators', 'minSamplesSplit', 'minSamplesLeaf'];
    for (const name of requiredNumericFields) {
      const field = fields[name];
      if (!field || !field.value || isNaN(Number(field.value)) || Number(field.value) <= 0) {
        showToast(`Invalid or missing value for ${name}`, true);
        saveBtn.disabled = false;
        return;
      }
    }

    formData.append("nEstimators", fields.nEstimators.value);
    formData.append("maxDepth", fields.maxDepth.value);
    formData.append("minSamplesSplit", fields.minSamplesSplit.value);
    formData.append("minSamplesLeaf", fields.minSamplesLeaf.value);
    formData.append("maxFeatures", fields.maxFeatures.value);
    formData.append("classWeight", fields.classWeight.value);
    formData.append("bootstrap", fields.bootstrap.checked);
    formData.append("oobScore", fields.oobScore.checked);
  }

  if (classifier === "KNN") {
    const nNeighbors = document.querySelector('[name="nNeighbors"]');
    const weights = document.querySelector('[name="weights"]');
    const metric = document.querySelector('[name="metric"]');

    if (!nNeighbors || !nNeighbors.value || isNaN(Number(nNeighbors.value)) || Number(nNeighbors.value) <= 0) {
      showToast("Invalid number of neighbors", true);
      saveBtn.disabled = false;
      return;
    }

    formData.append("nNeighbors", nNeighbors.value);
    formData.append("weights", weights.value);
    formData.append("metric", metric.value);
  }

  try {
    showToast("Saving...", false, true);

    const response = await fetch("{{ url_for('updateModelSettings', modelName=model.name) }}", {
      method: "POST",
      body: formData
    });

    if (response.ok) {
      localStorage.setItem("tuningComplete", "true");
      window.location.reload();
    } else {
      showToast("Failed to save settings.", true);
    }
  } catch (err) {
    showToast("Server error during save.", true);
  } finally {
    saveBtn.disabled = false;
  }
}

async function onClassifierChange() {
  const formData = new FormData();
  const classifier = document.getElementById("classifier").value;
  formData.append("modelType", classifier);

  showToast("Switching model...", false, true);

  const response = await fetch("{{ url_for('updateModelSettings', modelName=model.name) }}", {
    method: "POST",
    body: formData
  });

  if (response.ok) {
    localStorage.setItem("tuningComplete", "true");
    window.location.reload();
  } else {
    showToast("Failed to switch classifier", true);
  }
}

let toastInterval = null;

function showToast(message, isError = false, animated = false) {
  const toast = document.getElementById("tuneToast");
  const msg = document.getElementById("toastMessage");
  const dots = document.getElementById("toastDots");

  msg.textContent = message;
  dots.textContent = "";
  toast.classList.add("show");
  toast.style.backgroundColor = isError ? "#a94442" : "#222";

  if (animated) {
    let dotCount = 0;
    toastInterval = setInterval(() => {
      dotCount = (dotCount + 1) % 4;
      dots.textContent = ".".repeat(dotCount);
    }, 500);
  } else {
    clearInterval(toastInterval);
    dots.textContent = "";
    setTimeout(() => {
      toast.classList.remove("show");
    }, isError ? 5000 : 10000);
  }
}

function toggleManualParams() {
  const el = document.getElementById("advancedParams");
  const btn = document.getElementById("showAdvancedBtn");
  const isHidden = el.style.display === "none";
  showManualParams(isHidden);
}

function showManualParams(show) {
  const el = document.getElementById("advancedParams");
  const btn = document.getElementById("showAdvancedBtn");
  localStorage.setItem("showManualParams", show ? "true" : "false");

  el.style.display = show ? "block" : "none";
  if (btn) btn.textContent = show ? "Hide Manual Settings" : "Manual Settings";
}

function toggleOobField() {
  const bootstrap = document.getElementById("bootstrap").checked;
  document.getElementById("oobRow").style.display = bootstrap ? "flex" : "none";
}
</script>

<style>
.buttonRow {
  display: flex;
  gap: 1rem;
}
</style>